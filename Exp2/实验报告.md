# 实验2：采用A*算法编程解决8数码问题

**组内成员与分工情况：**

组长：

​		巩羽飞 - [整体业务逻辑设计、前端 + 后端实现、撰写报告]

组员：

​		李佳颉 - [资料搜集、测试、撰写报告]

​		廉涟 - [资料搜集、测试、撰写报告]

---

## 0. 引言：

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。

搜索算法是用于在数据集合中查找信息或定位特定项的过程或方法。

搜索算法的目标是使用一组规则或过程有效地找到目标项目或信息。

搜索算法用于各种领域，包括计算机科学、数学和工程，以解决涉及在大数据集中搜索解决方案的问题。

搜索算法的一些常见示例包括线性搜索、二进制搜索、宽度优先搜索、深度优先搜索和A*搜索。

线性搜索是一种简单的算法，它按顺序检查数据集中的每个项目，直到找到目标项目。

另一方面，二分搜索是一种更有效的算法，它通过将数据集反复分成两半，直到找到目标项。

广度优先搜索和深度优先搜索都是用于搜索图或树数据结构的算法。

广度优先搜索在移动到下一层之前访问给定深度级别上的所有节点；

而深度优先搜索在回溯之前尽可能沿着每个分支进行探索。

A*搜索是一种启发式算法，它结合了宽度优先和深度优先搜索的元素，以找到图或树数据结构中两点之间的最短路径。

它使用估计成本函数来引导搜索到目标项目或目的地。

---

## 1. A*算法：

### a. 定义

A* 搜索算法（A\*search algorithm），简称 A\* 算法，

是一种在图形平面上，对于**有多个节点的路径求出最低通过成本**的算法。

它属于图遍历（Graph traversal）和最佳优先搜索算法（Best-first search），亦是 BFS 的改进。



### b. 过程

定义起点$s$终点$t$，我们定义：

- 从起点开始的距离函数$g(x)$
- 点x到终点的预估代价距离函数$h(x)$
- 点x到终点的实际代价函数$h*(x)$
- 每个点的估价函数$f(x) = g(x) + h(x)$

每次从**优先队列**中取出一个$f$最小的元素，然后更新相邻的状态；

如果$h <= h*$，则A*算法能找到最优解；

上述条件下，如果$h$满足**三角形不等式**，则A*算法不会将重复节点加入队列。

特别地：

- 当$h = 0$时，A*算法变为Dijkstra
- 当$h = 0$且边权为1时，变为一般的BFS



---

## 2. 八数码问题：

### 题目简介：

在$3×3$的棋盘上，摆有$8$个棋子，每个棋子上标有$1至8$某一数字。棋盘中留有一个空格，空格用0来表示。

空格周围的棋子可以移到空格中，这样原来的位置就会变成空格。

给出一种初始布局和目标布局，找到一种从初始布局到目标布局**最少步骤**的移动方法。

---

## 3. 核心代码：

​																													代码预览图

<img src="C:\Users\22562\AppData\Roaming\Typora\typora-user-images\image-20230421095806121.png" alt="image-20230421095806121" style="zoom:80%;" />

### *FindZeroPosition():*

该函数的作用是在一个八数码问题的状态数组 `a` 中查找数字 0 的位置。如果数组中没有数字 0，则返回 -1。返回的数字代表 0 的位置，从左到右、从上到下从 0 开始编号。

### *HeuristicSearch():*

该函数是一个启发式搜索函数。它的作用是计算八数码问题的当前状态数组 `a` 与目标状态数组 `end` 之间的差异度。差异度的计算方式是计算当前状态数组 `a` 与目标状态数组 `end` 之间不同的数字的个数除以 2。由于每次只能交换两个数字的位置，所以这个差异度除以 2，得到的结果是需要移动的数字个数。

### *Node:*

`Node` 结构体表示八数码问题中的一个节点。它有四个字段：

- `state`：一个长度为 `n*n` 的数组，表示当前的状态。
- `parent`：指向父节点的指针。
- `cost`：当前节点的代价，即从初始状态到当前状态需要移动的次数。
- `direction`：当前节点从父节点移动的方向，用字符 `'U'`、`'D'`、`'L'`、`'R'` 表示上、下、左、右。

### *NodeHeap:*

`NodeHeap` 类型是一个优先队列，实现了 `container/heap` 包中的 `heap.Interface` 接口。`NodeHeap` 的比较函数是根据当前状态数组和目标状态数组的差异度以及当前节点的代价计算的，具体实现见 `Less()` 方法。同时，`NodeHeap` 也实现了 `Push()`、`Pop()`、`Swap()` 方法，以便使用 `container/heap` 包提供的堆排序算法。

### *Solve():*

函数`solve()`是该程序的核心部分，它实现了A\*算法来解决八数码问题。 

该函数首先定义了一个状态的`map`，以及一个优先队列`open`来存储节点。

接着，它创建了一个节点，初始化其父节点为空，代价为0，状态为给定的初始状态`a`。

然后，它将该节点推入`open`中，并将状态加入到状态`map`中。

之后，该函数进入循环，直到`open`为空或者找到目标状态为止。

每次从`open`中取出代价最小的节点（这个代价是通过计算当前节点到目标节点的启发距离和节点的代价相加来计算的），计算0的位置并尝试向四个方向扩展节点。如果扩展出来的节点已经在状态`map`中，说明已经遍历过该状态，则直接跳过；否则，将该节点的状态和代价等信息加入到新节点中，并将新节点推入到`open`中和状态`map`中。循环继续直到找到目标状态或者`open`为空，最后返回目标状态节点的代价。

---

## 4. 本地演示方法：

环境需求：Golang的开发运行环境

1. 打开VPN（用于加载远程静态资源）
2. 在根目录下打开终端，输入`go run main.go`
3. 打开浏览器，输入`http://localhost:8080/index`
4. 在输入栏输入下面的Example input，即`123804765283104765`
5. 点击Submit查看结果

---

## 5. 创新型扩展：

### a. 友好的图形界面

![image-20230524192256608](C:\Users\22562\AppData\Roaming\Typora\typora-user-images\image-20230524192256608.png)

![image-20230524192338170](C:\Users\22562\AppData\Roaming\Typora\typora-user-images\image-20230524192338170.png)

### b. 自主创新

采用Go语言实现轻量级的WebServer，可视化的交互界面给了用户更加良好的视觉体验。

---

## 6. 参考资料：

`https://en.wikipedia.org/wiki/A*_search_algorithm#Bounded_relaxation`

---



